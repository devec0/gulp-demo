//Example gulpfile
//Use to process image, sass, JS and iconfont assets automatically.
//-----------------------------------------------------------------
//James Hebden (james@tectonic.com.au)
//Developed for & @ Tectonic Digital (http://tectonic.com.au)
//-----------------------------------------------------------------

//Set up plugins.
//
//We are using gulp-load-plugins, so if a plugin is saved in the packages.json file for the project,
//you can simply call it by $.<suffix> -
//e.g. $.notify() instead of var notify = require('gulp-notify'); notify();
//
//Only include plugins explicitly if they will not autoload cleanly using gulp-load-plugins.
//for example if they do not have a gulp- prefix.
//
//Note: gulp-load-plugins can be configured to ignore the prefix, but it gets really tedious
//typing out the full plugin name all the time.

//Currently using process.cwd and node_modules prefix as a cludgey way
//to allow this gulp file to be required in child themes, rather than
//duplicating it into every child theme project. This allows us to
//simply use node.js' JS require statement to require this gulpfile,
//and all of it's tasks will be available to us in the child theme.

//First and foremost, get some gulp in our gulpfile (http://gulpjs.com/).
var gulp = require( process.cwd() + '/node_modules/gulp' ),

	//Load browsersync, and assign the 'sync' variable to point to it for later use (https://www.npmjs.org/package/browser-sync)
	sync = require( process.cwd() + '/node_modules/browser-sync' ),

	//Load browserify, which we use for compiling javascript modules, and controlling load order.
	browserify = require( process.cwd() + '/node_modules/browserify' ),

	//Load up vinyl-source-stream - used for converting browserify streams into gulp streams
	source = require( process.cwd() + '/node_modules/vinyl-source-stream' ),

	//Load gulp-load-plugins, which saves us manually loading each plugin
	$ = require( process.cwd() + '/node_modules/gulp-load-plugins' )();

//Theme paths. These are really just here to keep things neat for the rest of the file.
//Use the process cwd instead of the file's physical location, so that we can use this file
//in child projects without duplicating it.
var themeDir  = process.cwd() + '/',

		//Parent theme dir (mantle)
		themeParentDir = __dirname,

		//Where do our assets sit within our project?
		themeAssets = themeDir,

		//Which folder under assets holds the scss files?
	    themeSass  = themeAssets + 'sass/',

		//Which folder under assets holds the JavaScript files?
	    themeJS   = themeAssets + 'js/',

		//Which folder under assets holds our images?
	    themeImg  = themeAssets + 'img/',

		//And where are the icons we would like to have compiled into an iconfont?
		themeIcons = themeAssets + 'icons/',

        //The directory holds template for generating scss and html
        //for icon fonts. We use __dirname so that we can load them
        //from the parent theme, not the current directory, in case
        //they are different.
		themeIconTemplates = themeAssets + 'icons/templates/',

		//This is our output directory
		themeOut = themeDir + 'dist/',

		//We output optimised images to here
		themeOutImg = themeOut + 'img/',

		//We output our compiled CSS to theme.src.css, and then minify and pleeease it into theme.min.css
		//We leave it up to the application to decide which one to load. The minified source should be used
		//in production, else use the compiled source CSS for easier debugging.
		themeOutCSS = themeOut + 'css/',

		//The same goes for the JavaScript!
		themeOutJS = themeOut + 'js/',

		//This folder will get a copy of the compiled icon fonts, and a sample.html showing each glyph and CSS class.
		//The sample HTML file makes it easy to preview your icons, but also to work out which CSS class or unicode
		// character you should use in your code to generate a specific icon (p.s. - use the CSS).
		themeOutFonts = themeOut + 'fonts/';

//Header to insert into auto-generated files. Avoids head scratching when changes to a file are overwritten by gulp.
var header = "/*\r\n * This file is automatically generated, do not make changes!\r\n */";

//This task will generate an icon font from a folder full of SVG graphics.
//Big fat warning - SVGs look horrible when converted to a font if they contain
//cubic beizers, as opposed to quadratic beizers. See https://github.com/github/octicons/pull/9
//Hopefully the conversion in svg2ttf and the like will improve over time, for now, make sure
//you pick icons that are made by people who realise this. Entypo is one such set (entypo.com)
gulp.task( 'icons', function() {

	//Log the input folder information
	$.util.log( 'Icon font source folder: ', $.util.colors.magenta( themeIcons));
	$.util.log( 'Icon font template folder: ', $.util.colors.magenta( themeIconTemplates ));

	//Start a stream by priming it with the svg files in our icons directory.
	//the /**/ tells gulp to load *.svg files from the root and subdirectories recursively.
	return gulp.src(themeIcons + '/**/*.svg')

	//Pipe the stream to plumber, which adds error handlers so the stream is not broken should something fail
	//This is important, as breakage of the stream will otherwise terminate the stream. As we are using
	//gulp-watch to watch directories for changes, terminating the stream is a major time waster, as it means we
	//have to manually restart gulp - instead of fixing the problem and having gulp-watch automatically rerun the
	//task when the file changes.
	//We send any errors, including handy error test, to the gulp-notify error handler, which allows the full
	//error to be displayed in the notification area on Linux, OSX and Windows. We do this seperately on each
	//task so that we can specify message text that clearly identifies which task had issues. Otherwise, it is
	//possible to write your own error handler and reuse it on each task's stream.
	.pipe( $.plumber({errorHandler: $.notify.onError(function (error) { return "Icon font error: " + error; })}))

	//Load and run the gulp-iconfont plugin, by using the gulp-load-plugin syntax of $.iconfont
	.pipe( $.iconfont({

		//this gives our font a name. this makes up the filename, but also the namespace in CSS used to identify the font face.
		//we specify this here, and then again in the CSS/HTML generation. Could possible be done another way by pulling the
		//font name out of the stream.
		fontName: 'icons',

		//appending code points is cool - it generates events in the gulp stream that we can use later in the stream, that detail
		//the code points (characters) in the font that each SVG icon will occupy. We take those events and use them to
		//generate CSS and HTML so that each character gets a meaningful name
		appendCodepoints: true,

		//Attempt to fix different sizes icons
		normalize: true
	}))

	//Process the codepoints event mentioned above. .on handlers (event handlers) are for acting upon events.
	//This one will only respond to event/error objects of type 'codepoints',
	//everything else will just pass on by to continue through the gulp stream.
	//different plugins are often capable of generating errors/events on success or failure too.
	.on('codepoints', function(codepoints, options) {

	  //Sets the name of the font again, because reaching into the stream and plucking this out of the iconfont
		//likely involves some serious voodoo
		var fontName = 'icons';

		//options for the templating engine (swig!) used to create CSS & HTTML sample files.
		var fontOptions = {

			//in the templte, glyphs will refer to the list of codepoints we've had passed through
			//from gulp-iconfont
			glyphs: codepoints,

			//fontName will refer to... the font name.
			fontName: fontName,

			//fontPath will refer to the relative path, from the CSS files in your OUTPUT directory,
			//to the fonts in your output directory. This can be customised to suit.
			fontPath: '../fonts/',

			//classname is used when generating CSS as a prefix for the CSS. Generated classes referring
			//to individual glyphs will begin with this, and a class specifying font-wide defaults will also
			//be created with this name.
			className: 'icons'
		};

		//This is an example of a gulp stream, within a gulp stream! Gulpception!
		//Load in the SCSS template, to be used when generating font css.
		//We load these from __dirname, as they usually sit in the parent theme directory,
		//and we don't want to copy them around to child themes.
		gulp.src( themeIconTemplates + '*.scss' )

			//Use swig to generate the template
			.pipe( $.consolidate( 'swig', fontOptions ))

			.on('error', $.util.log)

			//Name the output file
			.pipe( $.rename ( '_' + fontName + '.scss' ))

			//Output files
			//This is something pretty cool. We output the generated SCSS template, into our
			//Sass assets directory. This triggers the CSS compilation task below to automatically
			//pick up the new SCSS file, and roll it into our combined CSS file. More Gulpception!
			.pipe( gulp.dest ( themeSass + '/fonts/' ))
    })
	//Now that we have processed the codepoints, we can write our font to disk
	.pipe( gulp.dest(themeOutFonts) )

	//Notify that the task is complete. TODO: Need to work out how to skip this if there's been an error.
	.pipe( $.notify({ title: 'Icon Font Compiled', message: 'Icon font has been compiled successfully.' }));

   //Ask browsersync nicely to reload ALL THE DEVICES!!!1!!1!
   sync.reload();
});

//concat, cssify, apply header, pleeease and minify our SASS, all in one go!
gulp.task( 'styles', function() {
	//In this task, we generate development styles, which are easier on they eye of the debugger
	//These are then minified seperately.
	//The correct file should be chosen based on environment, as explained earlier in the file.

	//Log the input folder information
	$.util.log('Sass source folder: ', $.util.colors.magenta(themeSass));

	//Load up all of our Sass SCSS files
	return gulp.src(themeSass + '/theme.scss')

	//Like in previous tasks, we set up plumber and an error handler
	.pipe( $.plumber({errorHandler: $.notify.onError(function (error) { return "Stylesheet error: " + error; })}))

	//Call gulp-ruby-sass
	//Note: We use ruby sass as it allows us to use the proper, offical, sass compiler. (http://sass-lang.com/)
	//No waiting for various compilers to catch up to Sass 3.3 support, for example. /me looks at gulp-sass
	.pipe( $.rubySass({

		//tell ruby-sass to run using the bundled version rather than system version
		bundleExec: true,

		//make compass work
		compass: true,

		//write out full, readable CSS for debugging. We compress it later
		style: 'expanded',

		//use 10 digits when outputing decimal number values. The default is 3, but we're fancy.
		precision: 10,

		//require the following sass plugins/ruby gems. This is why we set bundleExec to true :)
		//this would go very poorly if this wasn't installed prior to running ruby-sass.
		//this can be any gem, but it only makes sense to use sass plugins here.
		//Sass-globbing:
		//is useful as it allows you to use wildcards when specifying imports - e.g. @import 'modules/*'
		//Susy:
		//is a great framework for building mobile-first grid layouts, so let's use it
		//Breakpoint:
		//really nice and simple media query mixins, works will when using Susy for responsive grids
		//Compass:
		//is used by breakpoint, and provides lots of handy sass mixins, such as clearfix
		require: ['sass-globbing','susy','compass','breakpoint']
	}) )
	//Pleeease doesn't make you write out all of those irritating browser vendor prefixes. It does it for you :)
	//Note: It's a really good idea to do this processing, linting and compilation stuff before you concatenate,
	//otherwise it's tricky to work out which file has formatting issues, as you lose the context of
	//which lines belong to which files when concatenating.
	.pipe( $.pleeease() )

	//output what we have so far to theme.src.css. This will be uncompressed and readable. Concat
	//takes all of the various files we've piped into the stream and combines them into a single file.
	.pipe( $.concat('theme.src.css') )

	//Apply our header so it is clear that this file has been generated automatically, and shouldn't be edited.
	.pipe( $.header(header+'\r\n') )

	//And write the file out to disk
	.pipe( gulp.dest(themeOutCSS) )

	//This is why gulp is cool, we can keep working with the file without loading it again
	//We also keep all of the same information we were workign with when we wrote it to disk too
	//Now proceed to compress for production styles
	.pipe( $.minifyCss() )

	//Concat it out to a new file
	.pipe( $.concat('theme.min.css') )

	//Write the compressed file
	.pipe( gulp.dest(themeOutCSS ) )

	//And notify that we're done
	.pipe( $.notify({ title: 'CSS Compiled' , message: 'Sass files have been compiled successfully.' }));

	//Browsersync, do your thing
	sync.reload();
});

//This task will hint, concat, and compress the script assets
gulp.task( 'scripts' , function() {

	//output source folder configuration
	$.util.log('JS source folder: ', $.util.colors.magenta(themeJS));

	//Load all of our JS files from the source folder
	return gulp.src([ themeJS + '/libs/*.js', themeJS + '/modules/*.js', themeJS + '/theme.js' ])

	//Like other tasks, set up plumber to catch errors and feed them to notifier's error handler
	.pipe( $.plumber({errorHandler: $.notify.onError(function (error) { return "JavaScript error: " + error; })}))

	//Pipe the JS through the jshint plugin
	//.pipe( $.jshint())
	//Any findings by jshint end up in the stream, the default jshint reporter will format the findings and output
	//them to the console - there are other formatters you can use too by changing out the 'default' below
	//e.g. https://github.com/sindresorhus/jshint-stylish
	//.pipe( $.jshint.reporter('default'))
	//Concatenate our source files into one source js, this will be included
	//by out theme in development environments for easier debugging
	.pipe( $.concat( 'theme.src.js' ))

	//add our header to make sure the files are clearly identifiable as generated files
	.pipe( $.header(header+'\r\n') )

	//and write to disk
	.pipe( gulp.dest( themeOutJS ))

	//continue to uglify for production use
	//stripdebug will pull out any console.log, console.dir directives you may have left in by accident
	.pipe( $.stripDebug() )

	//uglify the JS, which just compresses it down to its smallest representation.
	.pipe( $.uglify() )

	//write our debugless and ugly JS out to the production JS file. Again, it's best to let you app
	//decide which one to use
	.pipe( $.rename( 'theme.min.js' ) )

	//compress it using gzip
	.pipe( $.gzip() )

	//out to disk you go
	.pipe( gulp.dest( themeOutJS ))

	//an incomplete example of using the if module. When I work out a condition that returns true if there has been
	//no errors in the stream (to replace the "true" statement), this will only fire when succesfuly (dreams)
	.pipe( $.if( true ,$.notify({ title: 'JS Compiled' , message: 'JS files have been compiled successfully.' })));

	//reloaderate
	sync.reload();
});

//optimise images! you'll be surprissed what a difference this makes to your pagespeed ranking.
//all of the optimisations here are lossless, so why not?
gulp.task( 'images', function() {
	//we create two filters here. filters in gulp are really useful for applying
	//different plugins/actions in a stream to different content without running seperate tasks,
	//and potentially duplicating effort and bloating your code.
	//theoretically all of the tasks in the file could be done in a single stream using filters,
	//but it's nice to be able to run things seperately, especially when you are watching directories.
	//you want to cut down your run time as much as possible and focus on processing what would have changed.

	//our first filter here is filters out image file types handled by the gulp-imagemin plugin (https://www.npmjs.org/package/gulp-imagemin)
	var imgFilter = $.filter('**/*.{png,gif,jpg,jpeg}'),
			//our second filter filters svg files, as we need to use a different plugin for optimising svg files
	    svgFilter = $.filter('**/*.svg');

	//grab all of our images and throw them down the stream
	return gulp.src( themeImg + '/**/*' )

	//using plumber and the notify error handler here to catch errors, like previous tasks
	.pipe( $.plumber({errorHandler: $.notify.onError(function (error) { return "Image optimisation error: " + error; })}))

	//here we apply the the image filter - which temporarily removes anything from the stream that does not match the filter
	.pipe( imgFilter )

	//we enable progressive encoding and interlacing in our images
	.pipe( $.imagemin({progressive: true, interlaced: true}) )

	//now we restore everything that was filtered out previously, bringing them back into the stream
	.pipe( imgFilter.restore() )

	//and then filter out everything but svg files
	.pipe( svgFilter )

	//run the gulp-svgmin plugin (https://www.npmjs.org/package/gulp-svgmin)
	.pipe( $.svgmin() )

	//restore everything that was filtered out (non-svg files)
	.pipe( svgFilter.restore() )

	//now we write everything out to disk. this will include everything that was picked up with gulp.src. For
	//files that matched one of our filters, the files will have been optimised. Everything else will
	//just come through as-is. In this example, we have filter coverage for all of the file types we are
	//loading with gulp.src, so this explanation is really just for documentation purposes.
	.pipe( gulp.dest( themeOutImg ) )

	//notify that we are done
	.pipe( $.notify({ title: 'Images Optimised', message: 'Image files have been optimised successfully.' }));

	//and reload
	sync.reload();
})

//I'm watching you, Wazowski. Always watching...
//gulp watch task. Starts watching the various asset directories for changes.
//We use the gulp-watch plugin instead of the built-in watch command (https://www.npmjs.org/package/gulp-watch)
//It gives a lot more flexibility, in that it won't break the stream on error when used with gulp-plumber, and can also
//be configured to provide endless streams (streams where the end event is not fired). This can be especially handy if you
//have tasks that can reprocess individual files, such as the image optimisation task, as it means that just the changed
//files can be run back through the stream processing. See the NPM page for examples.
gulp.task( 'watch', function() {
	//Fire up browsersync :)
	//Browsersync allows you to trigger reloads in browsers viewing your development site.
	//You can also syncronise data input, clicks and navgiation. Makes testing cross-platform and cross-device
	//super painless. It also looks pretty cool.
	//Each of the tasks call sync.reload when done to make sure any changes to your assets will also trigger a reload.
	sync({ online:true });

	//Here we have the watch statements. Each is configured to watch a set of files specified by the "glob" option.
	//As we are using globbing (e.g. the glob: "*.js" option), gulp-watch will fire events which trigger specified
	//tasks to be run whenever a file is added, deleted or changed.
	//This includes the files being added when gulp is first started. We set emitOnGlob to false to ensure that
	//files loaded when gulp is started do not trigger events, only later changes.
	//This is necessary as we run the tasks indivudually on gulp start, to make sure we start with a full and
	//clean asset compilation.
	//The "verbose" option enables console output for the workings of gulp-watch. This way we can see which
	//changes triggered a gulp task to be run.
	//The "name" parameter sets a human-friendly name to be shown in the console output, when showing verbose
	//output.
	//The last array argument contains a list of gulp tasks to run. You can also provide an event handler here
	//if you have more complicated processing of events in mind.
	gulp.watch(themeSass + '/**/*.scss', ['styles']);
	gulp.watch(themeJS + '/**/*.js', ['scripts']);
	gulp.watch(themeImg + '/**/*', ['images']);
	gulp.watch(themeIcons + '/**/*', ['icons']);
});

//the default task, DO ALL THE THINGS. Then watch all the things.
//the default task is called by gulp when no task is specified on the commandline.
gulp.task( 'default' , [ 'styles' , 'scripts' , 'images', 'icons', 'watch' ] );
